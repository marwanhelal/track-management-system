import { Request, Response } from 'express';
import { query } from '@/database/connection';
import { TimelineForecastService } from '@/services/timelineForecastService';
import { ResourceConflictService } from '@/services/resourceConflictService';
import { AuthenticatedRequest, ApiResponse } from '@/types';

// Get smart warnings for a project - FOCUSED ON DELAY DETECTION
export const getSmartWarnings = async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { project_id } = req.query;

    if (!project_id) {
      return res.status(400).json({
        success: false,
        error: 'Project ID is required'
      });
    }

    console.log('🧠 Smart Warning Analysis Starting...', { project_id });

    // Get project and phases
    const projectResult = await query(`
      SELECT * FROM projects WHERE id = $1
    `, [project_id]);

    if (projectResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Project not found'
      });
    }

    const project = projectResult.rows[0];

    const phasesResult = await query(`
      SELECT * FROM project_phases WHERE project_id = $1 ORDER BY phase_order
    `, [project_id]);

    const phases = phasesResult.rows;

    // Generate smart warnings
    const warnings = [];
    let totalRiskScore = 0;

    // 1. Timeline Deviation Analysis - PHASE DELAY DETECTION
    for (const phase of phases) {
      if (phase.status === 'in_progress' && phase.actual_start_date) {
        const plannedDuration = phase.planned_weeks * 7;
        const actualStart = new Date(phase.actual_start_date);
        const currentDate = new Date();
        const daysInProgress = Math.floor((currentDate.getTime() - actualStart.getTime()) / (1000 * 60 * 60 * 24));

        if (daysInProgress > plannedDuration) {
          const severity = daysInProgress > plannedDuration * 1.5 ? 'critical' : 'warning';
          warnings.push({
            id: `timeline-${phase.id}`,
            type: 'timeline_deviation',
            severity,
            title: `Phase ${phase.phase_name} Over Schedule`,
            message: `Phase has been running for ${daysInProgress} days, ${daysInProgress - plannedDuration} days over planned duration`,
            confidence_score: 92,
            risk_probability: 85,
            predicted_impact: {
              days: daysInProgress - plannedDuration,
              cost: (daysInProgress - plannedDuration) * 500,
              resources_affected: 1
            },
            project_id: parseInt(project_id as string),
            phase_ids: [phase.id],
            action_required: severity === 'critical',
            timestamp: new Date()
          });
          totalRiskScore += severity === 'critical' ? 25 : 15;
        }
      }

      // 2. DUE DATE WARNINGS - Check approaching phase end dates
      if (phase.status === 'in_progress' && phase.planned_start_date) {
        const plannedStart = new Date(phase.planned_start_date);
        const plannedEnd = new Date(plannedStart);
        plannedEnd.setDate(plannedStart.getDate() + (phase.planned_weeks * 7));

        const currentDate = new Date();
        const daysUntilDue = Math.floor((plannedEnd.getTime() - currentDate.getTime()) / (1000 * 60 * 60 * 24));

        if (daysUntilDue <= 7 && daysUntilDue > 0) {
          warnings.push({
            id: `due-date-${phase.id}`,
            type: 'approaching_deadline',
            severity: daysUntilDue <= 3 ? 'urgent' : 'warning',
            title: `Phase ${phase.phase_name} Due Soon`,
            message: `Phase is due in ${daysUntilDue} days (${plannedEnd.toLocaleDateString()})`,
            confidence_score: 95,
            risk_probability: 70,
            predicted_impact: {
              days: daysUntilDue,
              cost: 0,
              resources_affected: 1
            },
            project_id: parseInt(project_id as string),
            phase_ids: [phase.id],
            action_required: daysUntilDue <= 3,
            timestamp: new Date()
          });
          totalRiskScore += daysUntilDue <= 3 ? 20 : 10;
        }

        // Already overdue
        if (daysUntilDue < 0) {
          warnings.push({
            id: `overdue-${phase.id}`,
            type: 'overdue_phase',
            severity: 'critical',
            title: `Phase ${phase.phase_name} Overdue`,
            message: `Phase was due ${Math.abs(daysUntilDue)} days ago (${plannedEnd.toLocaleDateString()})`,
            confidence_score: 100,
            risk_probability: 100,
            predicted_impact: {
              days: Math.abs(daysUntilDue),
              cost: Math.abs(daysUntilDue) * 1000,
              resources_affected: 1
            },
            project_id: parseInt(project_id as string),
            phase_ids: [phase.id],
            action_required: true,
            timestamp: new Date()
          });
          totalRiskScore += 30;
        }
      }
    }

    // 3. Warning Flag Analysis
    const warningPhases = phases.filter((p: any) => p.warning_flag);
    if (warningPhases.length > 0) {
      warnings.push({
        id: `warning-flags-${project_id}`,
        type: 'phase_warnings',
        severity: warningPhases.length > 2 ? 'urgent' : 'warning',
        title: `${warningPhases.length} Phase(s) Flagged for Attention`,
        message: `Phases requiring attention: ${warningPhases.map((p: any) => p.phase_name).join(', ')}`,
        confidence_score: 95,
        risk_probability: 75,
        predicted_impact: {
          days: warningPhases.length * 3,
          cost: warningPhases.length * 1000,
          resources_affected: warningPhases.length
        },
        project_id: parseInt(project_id as string),
        phase_ids: warningPhases.map((p: any) => p.id),
        action_required: true,
        timestamp: new Date()
      });
      totalRiskScore += warningPhases.length * 10;
    }

    // 4. Resource Conflicts
    const conflicts = await ResourceConflictService.detectConflicts(project_id as string);
    if (conflicts.length > 0) {
      warnings.push({
        id: `resource-conflicts-${project_id}`,
        type: 'resource_conflict',
        severity: 'warning',
        title: `${conflicts.length} Resource Conflict(s) Detected`,
        message: `Resource scheduling conflicts identified in project phases`,
        confidence_score: 78,
        risk_probability: 60,
        predicted_impact: {
          days: conflicts.length * 2,
          cost: conflicts.length * 800,
          resources_affected: conflicts.length
        },
        project_id: parseInt(project_id as string),
        phase_ids: conflicts.map((c: any) => parseInt(c.phase_id)),
        action_required: true,
        timestamp: new Date()
      });
      totalRiskScore += conflicts.length * 8;
    }

    // Generate recommendations
    const recommendations = [];

    if (totalRiskScore > 30) {
      recommendations.push({
        id: 'critical-review',
        category: 'strategic',
        title: 'Immediate Project Review Required',
        description: 'High risk score detected. Schedule immediate stakeholder meeting.',
        priority_score: 95,
        confidence: 92,
        business_impact: 'high',
        implementation_complexity: 'simple'
      });
    }

    if (warningPhases.length > 0) {
      recommendations.push({
        id: 'phase-optimization',
        category: 'optimization',
        title: 'Phase Resource Reallocation',
        description: 'Reallocate resources to address flagged phases.',
        priority_score: 80,
        confidence: 88,
        business_impact: 'medium',
        implementation_complexity: 'moderate'
      });
    }

    const response: ApiResponse = {
      success: true,
      data: {
        warnings,
        total_warnings: warnings.length,
        total_risk_score: Math.min(totalRiskScore, 100),
        recommendations,
        project_health_score: Math.max(100 - totalRiskScore, 10),
        analysis_timestamp: new Date()
      },
      message: `Smart warning analysis completed. ${warnings.length} warnings detected.`
    };

    console.log(`✅ Smart Warning Analysis Complete - Risk Score: ${totalRiskScore}`, {
      project_id,
      warnings: warnings.length,
      recommendations: recommendations.length
    });

    res.status(200).json(response);
  } catch (error) {
    console.error('❌ Smart warning error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to analyze smart warnings'
    });
  }
};

// Get project health analysis
export const getProjectHealthAnalysis = async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { project_id } = req.params;

    console.log('🏥 Project Health Analysis Starting...', { project_id });

    const projectResult = await query(`
      SELECT * FROM projects WHERE id = $1
    `, [project_id]);

    if (projectResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Project not found'
      });
    }

    const project = projectResult.rows[0];

    const phasesResult = await query(`
      SELECT * FROM project_phases WHERE project_id = $1
    `, [project_id]);

    const phases = phasesResult.rows;

    // Calculate health metrics
    const totalPhases = phases.length;
    const completedPhases = phases.filter((p: any) => p.status === 'completed').length;
    const inProgressPhases = phases.filter((p: any) => p.status === 'in_progress').length;
    const warningPhases = phases.filter((p: any) => p.warning_flag).length;

    const completionPercentage = (completedPhases / totalPhases) * 100;
    const warningPercentage = (warningPhases / totalPhases) * 100;

    // Calculate health score (0-100)
    let healthScore = 100;
    healthScore -= warningPercentage * 2; // Penalty for warnings
    healthScore -= Math.max(0, inProgressPhases - 2) * 10; // Penalty for too many concurrent phases
    healthScore = Math.max(10, healthScore); // Minimum score

    const response: ApiResponse = {
      success: true,
      data: {
        project_id: parseInt(project_id),
        health_score: Math.round(healthScore),
        completion_percentage: Math.round(completionPercentage),
        performance_metrics: {
          total_phases: totalPhases,
          completed_phases: completedPhases,
          in_progress_phases: inProgressPhases,
          warning_phases: warningPhases,
          on_track_phases: totalPhases - warningPhases
        },
        risk_assessment: {
          level: healthScore > 80 ? 'low' : healthScore > 60 ? 'medium' : 'high',
          factors: warningPhases > 0 ? ['Phase warnings detected'] : ['No major issues'],
          mitigation_recommended: healthScore < 70
        },
        timeline_status: {
          predicted_completion: new Date(Date.now() + (project.planned_total_weeks * 7 * 24 * 60 * 60 * 1000)),
          variance_days: warningPhases * 3,
          confidence_level: Math.max(60, 95 - (warningPhases * 10))
        }
      },
      message: `Project health analysis completed. Health score: ${Math.round(healthScore)}%`
    };

    res.status(200).json(response);
  } catch (error) {
    console.error('❌ Project health analysis error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to analyze project health'
    });
  }
};

// Get timeline predictions
export const getTimelinePredictions = async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { project_id } = req.params;

    console.log('🔮 Timeline Prediction Starting...', { project_id });

    const forecast = await TimelineForecastService.generateForecast(project_id);

    const response: ApiResponse = {
      success: true,
      data: {
        forecast,
        predictions: {
          realistic_completion: forecast.predicted_completion_date,
          optimistic_completion: new Date(forecast.predicted_completion_date.getTime() - (7 * 24 * 60 * 60 * 1000)),
          pessimistic_completion: new Date(forecast.predicted_completion_date.getTime() + (14 * 24 * 60 * 60 * 1000)),
          confidence_interval: {
            lower: forecast.confidence_interval_lower,
            upper: forecast.confidence_interval_upper
          }
        },
        risk_factors: forecast.risk_factors,
        assumptions: forecast.assumptions,
        model_accuracy: forecast.model_accuracy
      },
      message: `Timeline forecast generated with ${forecast.model_accuracy}% accuracy`
    };

    res.status(200).json(response);
  } catch (error) {
    console.error('❌ Timeline prediction error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to predict project timeline'
    });
  }
};